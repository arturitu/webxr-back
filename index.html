<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Go Back (And Do It Again)</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0;
			}
			canvas {
				display: block;
			}
		</style>
</head>
<body>
<script type="module">
    import * as THREE from "/three.module.js";

	var camera, scene, renderer;
	var controller1, controller2;

	var raycaster, intersected = [];
	var tempMatrix = new THREE.Matrix4();

	var mouse = new THREE.Vector2();
	var intersection = null;

	var train, world;
	var ways = [];
	var actualWay = 2;
	var newWay = 2;
	var targetXpos = 0;
	var lerpSpeed = 0.9;

	var prevTime = performance.now();

	init();
	animate();

	function init() {

		scene = new THREE.Scene();
		scene.background = new THREE.Color( 0xdeb307 );
		scene.fog = new THREE.Fog( 0xdeb307, 0, 75 );

		world = new THREE.Object3D();
		world.position.y = -1.7;
		scene.add(world)

		train = new THREE.Object3D();
		scene.add( train );

		camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
		camera.layers.enable( 1 );
		scene.add( camera );

		var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
		light.position.set( 0.5, 1, 0.75 );
		scene.add( light );

		// floor

		var floorGeometry = new THREE.PlaneBufferGeometry( 2000, 2000, 100, 100 );
		floorGeometry.rotateX( - Math.PI / 2 );

		var floorMaterial = new THREE.MeshBasicMaterial( { color: 0xf6d242 } );

		var floor = new THREE.Mesh( floorGeometry, floorMaterial );
		world.add( floor );

		// point lights
		var spheres = []
		var sphereGeometry = new THREE.SphereBufferGeometry(0.35,4,2)
		var sphereMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, emissive: 0xffffff } );
		for ( var i = 0; i < 50; i ++ ) {
			var sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
			sphere.position.x = Math.floor( Math.random() * 5 ) * 2 - 4;
			sphere.position.y = 1.5;
			sphere.position.z = -20 * Math.ceil( Math.random() * 50 );
			spheres.push(sphere)
			world.add( sphere );
		}

		var wayGeometry = new THREE.PlaneBufferGeometry( 1.9, 2000, 1, 1 );
		wayGeometry.rotateX( - Math.PI / 2 );
		// ways
		for ( var i = 0; i < 5; i ++ ) {
			var wayMaterial = new THREE.MeshStandardMaterial({ color: 0xeebf2d });
			var way = new THREE.Mesh( wayGeometry, wayMaterial );
			way.name = 'way' + i;
			way.position.x = (i*2) - 4;
			way.position.y = 0.1;
			way.position.z = 0;
			ways.push(way)
			world.add(way);
			// TODO - tú no te mueves, se mueve todo lo demás
		}

		// objects

		var boxGeometry = new THREE.BoxBufferGeometry( 20, 20, 20 );
		// var boxMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, emissive: 0xffffff } );
		var boxMaterial = new THREE.MeshStandardMaterial( { color: 0xf6d242 } );
		for ( var i = 0; i < 500; i ++ ) {
			var box = new THREE.Mesh( boxGeometry, boxMaterial );
			box.position.x = Math.floor( Math.random() * 20 - 10 ) * 20;
			box.position.y = Math.floor( Math.random() * 5 ) * 20 + 20;
			box.position.z = -20 * Math.ceil( Math.random() * 50 );

			world.add( box );
		}

		//

		renderer = new THREE.WebGLRenderer( {antialias:true});
		renderer.domElement.id = "c";
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.vr.enabled = true;
		document.body.appendChild( renderer.domElement );

		// WebXR
		document.body.appendChild( THREE.WEBVR.createButton( renderer, { referenceSpaceType: 'local' } ) );

		// controllers

		function onSelectStart(event) {
			var controller = event.target;

			var intersections = getIntersections( controller );

			if ( intersections.length > 0 ) {
				var intersection = intersections[ 0 ];
				console.log(intersection.object);
				newWay = parseInt(intersection.object.name.substr(3,1), 10);
			}
		}

		function onSelectEnd() {
		}
		
		controller1 = renderer.vr.getController( 0 );
		controller1.addEventListener( 'selectstart', onSelectStart );
		controller1.addEventListener( 'selectend', onSelectEnd );
		scene.add( controller1 );

		controller2 = renderer.vr.getController( 1 );
		controller2.addEventListener( 'selectstart', onSelectStart );
		controller2.addEventListener( 'selectend', onSelectEnd );
		scene.add( controller2 );

		// raycaster
		raycaster = new THREE.Raycaster();

		// helpers

		var geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );
		var material = new THREE.LineBasicMaterial( {color: 0x000000} );
		var line = new THREE.Line( geometry, material);
		line.name = 'line';
		line.scale.z = 5;

		controller1.add( line.clone() );
		controller2.add( line.clone() );

		window.addEventListener( 'resize', onWindowResize, false );
		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		document.addEventListener( 'click', onClick, false );

	}

	function onDocumentMouseMove( event ) {

		event.preventDefault();
		if(!event.targetTouches){
			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			
			doFallbackRaycast();
		}
	}

	function onClick( event ) {

		event.preventDefault();

		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

		doFallbackRaycast();
		
		if(intersected.length){
			newWay = parseInt(intersected[0].name.substr(3,1), 10);
		}

	}

	// Intersection methods

	function doFallbackRaycast () {
		cleanIntersected();

		raycaster.setFromCamera( mouse, camera );
		var intersections = raycaster.intersectObjects( ways );
		intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null;
		if (intersection !== null ) {
			var object = intersection.object;
			object.material.emissive.r = 1;
			intersected.push( object );
		}
	}

	function getIntersections( controller ) {

		tempMatrix.identity().extractRotation( controller.matrixWorld );

		raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );
		raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );

		return raycaster.intersectObjects( ways );
	}

	function intersectObjects( controller ) {

		// Do not highlight when already selected

		if ( controller.userData.selected !== undefined ) return;

		var line = controller.getObjectByName( 'line' );
		var intersections = getIntersections( controller );

		if ( intersections.length > 0 ) {

			var intersection = intersections[ 0 ];

			var object = intersection.object;
			object.material.emissive.r = 1;
			intersected.push( object );

			line.scale.z = intersection.distance;

		} else {

			line.scale.z = 5;

		}

	}

	function cleanIntersected() {

		while ( intersected.length ) {

			var object = intersected.pop();
			object.material.emissive.r = 0;

		}

	}

	// movement
	function getTargetX (way) {
		return ((ways.length - 1) - way)*2 - 4
	}

	//

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}

	function animate() {
		renderer.setAnimationLoop( render );
	}

	function render() {
		var time = performance.now();
		var delta = ( time - prevTime ) / 1000;

		world.position.z += 8 * delta;

		if(newWay !== actualWay) {
			actualWay = newWay
			targetXpos = getTargetX(newWay);
		}

		if(targetXpos !== world.position.x){
			world.position.x = THREE.Math.lerp(targetXpos, world.position.x, lerpSpeed)
		}
		prevTime = time;
		if(renderer.vr.isPresenting()){
			cleanIntersected();

			intersectObjects( controller1 );
			intersectObjects( controller2 );
			lerpSpeed = 0.75
		} else {
			lerpSpeed = 0.9
		}

		renderer.render( scene, camera );

	}
</script>
</body>
</html>