<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Go Back (And Do It Again)</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0;
			}
			canvas {
				display: block;
			}
		</style>
</head>
<body>
<script type="module">
    import * as THREE from "/three.module.js";

	var camera, scene, renderer;
	var controller1, controller2;

	var raycaster, intersected = [];
	var tempMatrix = new THREE.Matrix4();

	var mouse = new THREE.Vector2();
	var intersection = null;

	var isVRActive = false;

	var world;
	var ways = [];
	var tokens;
	var wayLength = 200;
	var actualWay = 2;
	var newWay = 2;
	var targetXpos = 0;
	var lerpSpeed = 0.9;

	var solved = false;
	var gameSpeed = 10;
	var cycle = 0;

	var reward;

	var prevTime = performance.now();

	init();
	animate();

	function init() {

		scene = new THREE.Scene();
		scene.background = new THREE.Color( 0xdeb307 );
		scene.fog = new THREE.Fog( 0xdeb307, 0, 45 );

		world = new THREE.Object3D();
		world.position.y = -1.7;
		world.position.z = -8;
		scene.add(world)

		camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
		camera.layers.enable( 1 );
		scene.add( camera );

		var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
		light.position.set( 0.5, 1, 0.75 );
		scene.add( light );

		// reward
		var rewardMaterial = new THREE.LineBasicMaterial( { color: 0xffffff } );
		var rewardGeometry = new THREE.Geometry();
		var segmentCount = 4;
		var radius = 0.05;
		for (var i = 0; i <= segmentCount; i++) {
			var theta = (i / segmentCount) * Math.PI * 2;
			rewardGeometry.vertices.push(
				new THREE.Vector3(
					Math.cos(theta) * radius,
					Math.sin(theta) * radius,
					0));
		}
		reward = new THREE.Line(rewardGeometry, rewardMaterial);
		reward.position.z = -0.5;
		reward.position.y = -0.05;
		reward.visible = false;
		scene.add( reward );

		// tokens
		tokens = new THREE.Group();
		var spheres = []
		var sphereGeometry = new THREE.SphereBufferGeometry(0.35,4,2)
		var sphereMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, emissive: 0xffffff } );
		var sphereMaterial2 = new THREE.MeshStandardMaterial( { color: 0xff00ff, emissive: 0xff00ff } );
		for ( var i = 0; i < 5; i ++ ) {
			var sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
			sphere.position.x = i * 2 - 4;
			sphere.position.y = 1.5;
			sphere.position.z = -50;
			spheres.push(sphere);
			tokens.add(sphere);
			world.add( tokens );
		}

		// ways
		var wayGeometry = new THREE.PlaneBufferGeometry( 1.9, wayLength, 1, 1 );
		wayGeometry.rotateX( - Math.PI / 2 );
		for ( var i = 0; i < 5; i ++ ) {
			var wayMaterial = new THREE.MeshStandardMaterial({ color: 0xeebf2d });
			var way = new THREE.Mesh( wayGeometry, wayMaterial );
			way.name = 'way' + i;
			way.position.x = (i*2) - 4;
			way.position.y = 0.1;
			way.position.z = 0;
			ways.push(way)
			world.add(way);
		}

		// objects

		// var boxGeometry = new THREE.BoxBufferGeometry( 20, 20, 20 );
		// // var boxMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, emissive: 0xffffff } );
		// var boxMaterial = new THREE.MeshStandardMaterial( { color: 0xf6d242 } );
		// for ( var i = 0; i < 500; i ++ ) {
		// 	var box = new THREE.Mesh( boxGeometry, boxMaterial );
		// 	box.position.x = Math.floor( Math.random() * 20 - 10 ) * 20;
		// 	box.position.y = Math.floor( Math.random() * 5 ) * 20 + 20;
		// 	box.position.z = -20 * Math.ceil( Math.random() * 50 );

		// 	world.add( box );
		// }

		//

		renderer = new THREE.WebGLRenderer( {antialias:true});
		renderer.domElement.id = "c";
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.vr.enabled = true;
		document.body.appendChild( renderer.domElement );

		// WebXR
		document.body.appendChild( THREE.WEBVR.createButton( renderer, { referenceSpaceType: 'local' } ) );

		// controllers

		function onSelectStart(event) {
			var controller = event.target;

			var intersections = getIntersections( controller );

			if ( intersections.length > 0 ) {
				var intersection = intersections[ 0 ];
				console.log(intersection.object);
				newWay = parseInt(intersection.object.name.substr(3,1), 10);
			}
		}

		function onSelectEnd() {
		}
		
		controller1 = renderer.vr.getController( 0 );
		controller1.addEventListener( 'selectstart', onSelectStart );
		controller1.addEventListener( 'selectend', onSelectEnd );
		scene.add( controller1 );

		controller2 = renderer.vr.getController( 1 );
		controller2.addEventListener( 'selectstart', onSelectStart );
		controller2.addEventListener( 'selectend', onSelectEnd );
		scene.add( controller2 );

		// raycaster
		raycaster = new THREE.Raycaster();

		// helpers

		var geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );
		var material = new THREE.LineBasicMaterial( {color: 0x000000} );
		var line = new THREE.Line( geometry, material);
		line.name = 'line';
		line.scale.z = 5;

		controller1.add( line.clone() );
		controller2.add( line.clone() );

		window.addEventListener( 'resize', onWindowResize, false );
		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		document.addEventListener( 'click', onClick, false );

	}

	function onDocumentMouseMove( event ) {

		event.preventDefault();
		if(!event.targetTouches){
			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			
			doFallbackRaycast();
		}
	}

	function onClick( event ) {

		event.preventDefault();

		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

		doFallbackRaycast();
		
		if(intersected.length){
			newWay = parseInt(intersected[0].name.substr(3,1), 10);
		}

	}

	// Intersection methods

	function doFallbackRaycast () {
		cleanIntersected();

		raycaster.setFromCamera( mouse, camera );
		var intersections = raycaster.intersectObjects( ways );
		intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null;
		if (intersection !== null ) {
			var object = intersection.object;
			object.material.emissive.r = 1;
			intersected.push( object );
		}
	}

	function getIntersections( controller ) {

		tempMatrix.identity().extractRotation( controller.matrixWorld );

		raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );
		raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );

		return raycaster.intersectObjects( ways );
	}

	function intersectObjects( controller ) {

		// Do not highlight when already selected

		if ( controller.userData.selected !== undefined ) return;

		var line = controller.getObjectByName( 'line' );
		var intersections = getIntersections( controller );

		if ( intersections.length > 0 ) {

			var intersection = intersections[ 0 ];

			var object = intersection.object;
			object.material.emissive.r = 1;
			intersected.push( object );

			line.scale.z = intersection.distance;

		} else {

			line.scale.z = 5;

		}

	}

	function cleanIntersected() {

		while ( intersected.length ) {

			var object = intersected.pop();
			object.material.emissive.r = 0;

		}

	}

	// movement
	function getTargetX (way) {
		return ((ways.length - 1) - way)*2 - 4
	}

	// Game logic

	function solve(){
		console.log('pre');
		tokens.visible = false;
		solved = true
		reward.scale.set(0.1, 0.1, 0.1);
		reward.visible = true;
	}

	function newCycle(){
		cycle ++;
		console.log(cycle, actualWay);
		world.position.z = 0;
		reward.position.z = -0.5;
		reward.visible = false;
		solved = false;
	}

	function postSolved(){
		console.log('post');
		tokens.visible = true;
	}

	//

	function toggleVRActive(){
		controller1.visible = renderer.vr.isPresenting();
		controller2.visible = renderer.vr.isPresenting();
	}
	//

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}

	function animate() {
		renderer.setAnimationLoop( render );
	}

	function render() {
		var time = performance.now();
		var delta = ( time - prevTime ) / 1000;

		world.position.z += gameSpeed * delta;
		if(Math.abs(world.position.z) >= wayLength/4 -2 && !solved){
			solve()
		}
		if (Math.abs(world.position.z) >= wayLength/4 + 2 && !tokens.visible){
			postSolved()
		}
		if(Math.abs(world.position.z) >= wayLength/4 + 10){
			newCycle()
		}

		if(newWay !== actualWay) {
			actualWay = newWay
			targetXpos = getTargetX(newWay);
		}

		if(targetXpos !== world.position.x){
			world.position.x = THREE.Math.lerp(targetXpos, world.position.x, lerpSpeed)
		}
		if(reward.visible){
			var newScale = THREE.Math.lerp(2.5, reward.scale.x, lerpSpeed);
			reward.scale.set(newScale, newScale, newScale);
			reward.position.z += 0.01;
		}

		prevTime = time;

		if(isVRActive !== renderer.vr.isPresenting()){
			toggleVRActive();
		}
		if(renderer.vr.isPresenting()){
			cleanIntersected();

			intersectObjects( controller1 );
			intersectObjects( controller2 );
			lerpSpeed = 0.75
		} else {
			lerpSpeed = 0.9
		}

		renderer.render( scene, camera );

	}
</script>
</body>
</html>