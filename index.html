<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Go Back (And Do It Again)</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0;
			}
			canvas {
				display: block;
			}
		</style>
</head>
<body>
<script type="module">
    import * as THREE from "/three.module.js";

	var camera, scene, renderer;
	var controller1, controller2;

	var raycaster, intersected = [];
	var tempMatrix = new THREE.Matrix4();

	var mouse = new THREE.Vector2();
	var intersection = null;

	var isVRActive = false;

	// var bgColor = 0xdeb307;
	var bgColor = 0x222222;

	var world;
	var ways = [];
	// var wayColor = 0xeebf2d
	// var wayColorOver = 0xf4d36b
	var wayColor = 0x333333;
	var wayColorOver = 0x444444;
	var wayLength = 200;
	var actualWay = 2;
	var newWay = 2;
	var correctWay = 2;

	var tokens;
	var bigTokens;
	var colorArr = [
		0xfb39ca,
		0xfdca2a,
		0x2bca20,
		0xfc9125,
		0x0d6afc,
		0x6419cb,
		0xffffff,
		0xfa0018
	]
	
	var targetXpos = 0;
	var lerpSpeed = 0.9;

	var solved = false;
	var gameSpeed = 10;
	var cycle = 0;

	var rewards;

	var prevTime = performance.now();

	init();
	animate();

	function init() {

		scene = new THREE.Scene();
		scene.background = new THREE.Color( bgColor );
		scene.fog = new THREE.Fog( bgColor, 0, 45 );

		world = new THREE.Object3D();
		world.position.y = -1.7;
		world.position.z = -8;
		scene.add(world)

		camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
		camera.layers.enable( 1 );
		// camera.rotation.y = Math.PI;
		scene.add( camera );

		var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
		light.position.set( 0.5, 1, 0.75 );
		scene.add( light );

		// reward
		rewards = new THREE.Group();
		var rewardMaterial = new THREE.LineBasicMaterial( { color: 0xffffff } );
		for ( var i = 0; i < 5; i ++ ) {
			var rewardGeometry;
			switch (i) {
				case 0:
				rewardGeometry = getRedwardGeometry(3);
					break;
				case 1:
				rewardGeometry = getRedwardGeometry(4);
					break;
				case 2:
				rewardGeometry = getRedwardGeometry(5);
					break;
				case 3:
				rewardGeometry = getRedwardGeometry(6);
					break;
				case 4:
				rewardGeometry = getRedwardGeometry(32);
					break;
			}
			var reward = new THREE.Line(rewardGeometry, rewardMaterial);
			reward.name = i;
			rewards.add(reward);
		}
		rewards.position.z = -0.5;
		rewards.position.y = -0.05;
		rewards.visible = false;
		scene.add( rewards );

		// tokens
		tokens = new THREE.Group();
		bigTokens = new THREE.Group();
		bigTokens.position.set(0, 2, -5);
		bigTokens.visible = false;
		scene.add(bigTokens);
		for ( var i = 0; i < 5; i ++ ) {
			var tokenGeometry
			switch (i) {
				case 0:
				// tokenGeometry = new THREE.SphereBufferGeometry(0.35,4,2)
				tokenGeometry = new THREE.RingBufferGeometry(0.25,0.35,3)
					break;
				case 1:
				tokenGeometry = new THREE.RingBufferGeometry(0.25,0.35,4)
					break;
				case 2:
				tokenGeometry = new THREE.RingBufferGeometry(0.25,0.35,5)
					break;
				case 3:
				tokenGeometry = new THREE.RingBufferGeometry(0.25,0.35,6)
					break;
				case 4:
				tokenGeometry = new THREE.RingBufferGeometry(0.25,0.35,32)
					break;
			}
			var tokenMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, side: THREE.DoubleSide } );
			var token = new THREE.Mesh( tokenGeometry, tokenMaterial );
			var clonedToken = new THREE.Mesh( tokenGeometry, tokenMaterial );
			token.name = i;
			clonedToken.name = i;
			token.position.x = i * 2 - 4;
			token.position.y = 1.5;
			token.position.z = -50;
			tokens.add(token);
			bigTokens.add(clonedToken);
			world.add( tokens );
		}

		// ways
		var wayGeometry = new THREE.PlaneBufferGeometry( 1.9, wayLength, 1, 1 );
		wayGeometry.rotateX( - Math.PI / 2 );
		for ( var i = 0; i < 5; i ++ ) {
			var wayMaterial = new THREE.MeshBasicMaterial({ color: wayColor });
			var way = new THREE.Mesh( wayGeometry, wayMaterial );
			way.name = 'way' + i;
			way.position.x = (i*2) - 4;
			way.position.y = 0.1;
			way.position.z = 0;
			ways.push(way)
			world.add(way);
		}

		//

		renderer = new THREE.WebGLRenderer( {antialias:true});
		renderer.domElement.id = "c";
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.vr.enabled = true;
		document.body.appendChild( renderer.domElement );

		// WebXR
		document.body.appendChild( THREE.WEBVR.createButton( renderer, { referenceSpaceType: 'local' } ) );

		// controllers

		function onSelectStart(event) {
			var controller = event.target;

			var intersections = getIntersections( controller );

			if ( intersections.length > 0 ) {
				var intersection = intersections[ 0 ];
				console.log(intersection.object);
				newWay = parseInt(intersection.object.name.substr(3,1), 10);
			}
		}

		function onSelectEnd() {
		}
		
		controller1 = renderer.vr.getController( 0 );
		controller1.addEventListener( 'selectstart', onSelectStart );
		controller1.addEventListener( 'selectend', onSelectEnd );
		scene.add( controller1 );

		controller2 = renderer.vr.getController( 1 );
		controller2.addEventListener( 'selectstart', onSelectStart );
		controller2.addEventListener( 'selectend', onSelectEnd );
		scene.add( controller2 );

		// raycaster
		raycaster = new THREE.Raycaster();

		// helpers

		var geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );
		var material = new THREE.LineBasicMaterial( {color: 0xffffff} );
		var line = new THREE.Line( geometry, material);
		line.name = 'line';
		line.scale.z = 5;

		controller1.add( line.clone() );
		controller2.add( line.clone() );

		window.addEventListener( 'resize', onWindowResize, false );
		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		document.addEventListener( 'click', onClick, false );

		newCycle();

	}

	function onDocumentMouseMove( event ) {

		event.preventDefault();
		if(!event.targetTouches){
			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			
			doFallbackRaycast();
		}
	}

	function onClick( event ) {

		event.preventDefault();

		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

		doFallbackRaycast();
		
		if(intersected.length){
			newWay = parseInt(intersected[0].name.substr(3,1), 10);
		}

	}

	// Intersection methods

	function doFallbackRaycast () {
		cleanIntersected();

		raycaster.setFromCamera( mouse, camera );
		var intersections = raycaster.intersectObjects( ways );
		intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null;
		if (intersection !== null ) {
			var object = intersection.object;
			object.material.color.set(wayColorOver);
			intersected.push( object );
		}
	}

	function getIntersections( controller ) {

		tempMatrix.identity().extractRotation( controller.matrixWorld );

		raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );
		raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );

		return raycaster.intersectObjects( ways );
	}

	function intersectObjects( controller ) {

		// Do not highlight when already selected

		if ( controller.userData.selected !== undefined ) return;

		var line = controller.getObjectByName( 'line' );
		var intersections = getIntersections( controller );

		if ( intersections.length > 0 ) {

			var intersection = intersections[ 0 ];

			var object = intersection.object;
			object.material.color.set(wayColorOver);
			intersected.push( object );

			line.scale.z = intersection.distance;

		} else {

			line.scale.z = 5;

		}

	}

	function cleanIntersected() {

		while ( intersected.length ) {

			var object = intersected.pop();
			object.material.color.set(wayColor);

		}

	}

	// movement
	function getTargetX (way) {
		return ((ways.length - 1) - way)*2 - 4
	}

	// utils
	function shuffle(array) {
		array.sort(() => Math.random() - 0.5);
	}

	function getRedwardGeometry(segmentCount){
		var rewardGeometry = new THREE.Geometry();
		var radius = 0.05;
		for (var i = 0; i <= segmentCount; i++) {
			var theta = (i / segmentCount) * Math.PI * 2;
			rewardGeometry.vertices.push(
				new THREE.Vector3(
					Math.cos(theta) * radius,
					Math.sin(theta) * radius,
					0));
		}
		return rewardGeometry;
	}

	// Game logic
	function solve(){
		console.log('pre');
		if(tokens.children[actualWay].name === bigTokens.children[correctWay].name){
			console.log('ok');
		} else {
			console.log('ko');
		}
		tokens.visible = false;
		solved = true;
		rewards.scale.set(0.1, 0.1, 0.1);
		rewards.visible = true;
	}

	function newCycle(){
		// console.log(cycle, actualWay, tokens.children[actualWay].name, colorArr[actualWay], bigTokens.children[correctWay].name);
		cycle ++;
		correctWay = Math.floor(Math.random() * 5);
		bigTokens.visible = true;
		for (var i = 0; i < bigTokens.children.length; i++) {
			if(bigTokens.children[i].name === correctWay){
				bigTokens.children[i].visible = true;
			} else {
				bigTokens.children[i].visible = false;
			}
		}
		for (var i = 0; i < rewards.children.length;i++) {
			if(rewards.children[i].name === correctWay){
				rewards.children[i].visible = true;
			} else {
				rewards.children[i].visible = false;
			}
		}
		world.position.z = 0;
		rewards.position.z = -0.5;
		rewards.visible = false;
		solved = false;
		shuffle(tokens.children);
		shuffle(colorArr);
		for (var i =0; i < tokens.children.length; i++) {
			tokens.children[i].position.x = i * 2 - 4;
			var tmpColor = colorArr[i];
			tokens.children[i].material.color.set(tmpColor);
			// tokens.children[i].material.emissive.set(tmpColor);
		}
	}

	function postSolved(){
		console.log('post');
		bigTokens.visible = false;
		tokens.visible = true;
	}

	//

	function toggleVRActive(){
		controller1.visible = renderer.vr.isPresenting();
		controller2.visible = renderer.vr.isPresenting();
	}
	//

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}

	function animate() {
		renderer.setAnimationLoop( render );
	}

	function render() {
		var time = performance.now();
		var delta = ( time - prevTime ) / 1000;

		world.position.z += gameSpeed * delta;
		if(Math.abs(world.position.z) >= wayLength/4 -2 && !solved){
			solve()
		}
		if (Math.abs(world.position.z) >= wayLength/4 + 2 && !tokens.visible){
			postSolved()
		}
		if(Math.abs(world.position.z) >= wayLength/4 + 10){
			newCycle()
		}

		if(newWay !== actualWay) {
			actualWay = newWay
			targetXpos = getTargetX(newWay);
		}

		if(targetXpos !== world.position.x){
			world.position.x = THREE.Math.lerp(targetXpos, world.position.x, lerpSpeed)
		}
		if(rewards.visible){
			var newScale = THREE.Math.lerp(2.5, rewards.scale.x, lerpSpeed);
			rewards.scale.set(newScale, newScale, newScale);
			rewards.position.z += 0.01;
		}

		prevTime = time;

		if(isVRActive !== renderer.vr.isPresenting()){
			toggleVRActive();
		}
		if(renderer.vr.isPresenting()){
			cleanIntersected();

			intersectObjects( controller1 );
			intersectObjects( controller2 );
			lerpSpeed = 0.75
		} else {
			lerpSpeed = 0.9
		}

		renderer.render( scene, camera );

	}
</script>
</body>
</html>