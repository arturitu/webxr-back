<!DOCTYPE html>
<html lang="en">
	<head>
		<title>webxr-back</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0;
			}
			canvas {
				display: block;
			}
		</style>
</head>
<body>
<script type="module">
    import * as THREE from "/three.module.js";
    var PointerLockControls = function ( camera, domElement ) {

        this.domElement = domElement || document.body;

        //
        // internals
        //

        var scope = this;

        var changeEvent = { type: 'change' };

        var euler = new THREE.Euler( 0, 0, 0, 'YXZ' );

        var PI_2 = Math.PI / 2;

        function onMouseMove( event ) {

			var c = document.getElementById("c")
            var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

            euler.setFromQuaternion( camera.quaternion );

            euler.y = (1 - normalize(event.x, c.width, 0)) * Math.PI*2 - Math.PI;
            euler.x = (1 - normalize(event.y, c.height, 0)) * Math.PI - PI_2;

            // euler.x = Math.max( - PI_2, Math.min( PI_2, euler.x ) );

            camera.quaternion.setFromEuler( euler );

            scope.dispatchEvent( changeEvent );

		}
		
		function normalize (val, max, min) { return (val - min) / (max - min) }

        this.connect = function () {

            document.addEventListener( 'mousemove', onMouseMove, false );

        };

        this.disconnect = function () {

            document.removeEventListener( 'mousemove', onMouseMove, false );

        };

        this.dispose = function () {

            this.disconnect();

        };

        this.getObject = function () { // retaining this method for backward compatibility

            return camera;

        };

        this.getDirection = function () {

            var direction = new THREE.Vector3( 0, 0, - 1 );

            return function ( v ) {

                return v.copy( direction ).applyQuaternion( camera.quaternion );

            };

        }();

        this.connect();

    };

    PointerLockControls.prototype = Object.create( THREE.EventDispatcher.prototype );
    PointerLockControls.prototype.constructor = PointerLockControls;

	var camera, scene, renderer, controls;
	var controller1, controller2;
	var train;

	var moveForward = false;
	var moveBackward = false;
	var moveLeft = false;
	var moveRight = false;

	var prevTime = performance.now();
	var velocity = new THREE.Vector3();
	var direction = new THREE.Vector3();

	init();
	animate();

	function init() {

		scene = new THREE.Scene();
		scene.background = new THREE.Color( 0xdeb307 );
		scene.fog = new THREE.Fog( 0xdeb307, 0, 75 );

		train = new THREE.Object3D();
		train.position.y = 1.7;
		scene.add( train );

		camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
		camera.layers.enable( 1 );
		train.add( camera );

		var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
		light.position.set( 0.5, 1, 0.75 );
		scene.add( light );

		controls = new PointerLockControls( train );

		scene.add( controls.getObject() );

		var onKeyDown = function ( event ) {

			switch ( event.keyCode ) {

				case 38: // up
				case 87: // w
					moveForward = true;
					break;

				case 37: // left
				case 65: // a
					moveLeft = true;
					break;

				case 40: // down
				case 83: // s
					moveBackward = true;
					break;

				case 39: // right
				case 68: // d
					moveRight = true;
					break;
			}

		};

		var onKeyUp = function ( event ) {

			switch ( event.keyCode ) {

				case 38: // up
				case 87: // w
					moveForward = false;
					break;

				case 37: // left
				case 65: // a
					moveLeft = false;
					break;

				case 40: // down
				case 83: // s
					moveBackward = false;
					break;

				case 39: // right
				case 68: // d
					moveRight = false;
					break;

			}

		};

		document.addEventListener( 'keydown', onKeyDown, false );
		document.addEventListener( 'keyup', onKeyUp, false );

		// floor

		var floorGeometry = new THREE.PlaneBufferGeometry( 2000, 2000, 100, 100 );
		floorGeometry.rotateX( - Math.PI / 2 );

		var floorMaterial = new THREE.MeshBasicMaterial( { color: 0xf6d242 } );

		var floor = new THREE.Mesh( floorGeometry, floorMaterial );
		scene.add( floor );

		// point lights
		var spheres = []
		var sphereGeometry = new THREE.SphereBufferGeometry(0.5,4,2)
		var sphereMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, emissive: 0xffffff } );
		for ( var i = 0; i < 50; i ++ ) {
			var sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
			sphere.position.x = Math.floor( Math.random() * 20 - 10 ) * 10;
			sphere.position.y = Math.floor( Math.random() * 5 ) * 20 + 5;
			sphere.position.z = Math.floor( Math.random() * 20 - 10 ) * 10;
			spheres.push(sphere)
			scene.add( sphere );
		}

		// lines
		var geometry = new THREE.BufferGeometry();
		var material = new THREE.LineBasicMaterial( { color: 0xffffff } );
		var positions = [];
		for ( var i = 0; i < spheres.length; i ++ ) {
			var x = spheres[i].position.x;
			var y = spheres[i].position.y;
			var z = spheres[i].position.z;
			// positions
			positions.push( x, y, z );
		}
		geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
		// geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
		geometry.computeBoundingSphere();
		var line = new THREE.Line( geometry, material );
		scene.add( line );
		// objects

		var boxGeometry = new THREE.BoxBufferGeometry( 20, 20, 20 );
		// var boxMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, emissive: 0xffffff } );
		var boxMaterial = new THREE.MeshStandardMaterial( { color: 0xf6d242 } );
		for ( var i = 0; i < 500; i ++ ) {
			var box = new THREE.Mesh( boxGeometry, boxMaterial );
			box.position.x = Math.floor( Math.random() * 20 - 10 ) * 20;
			box.position.y = Math.floor( Math.random() * 5 ) * 20 + 10;
			box.position.z = Math.floor( Math.random() * 20 - 10 ) * 20;

			scene.add( box );

		}

		//

		renderer = new THREE.WebGLRenderer( {antialias:true});
		renderer.domElement.id = "c";
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.vr.enabled = true;
		document.body.appendChild( renderer.domElement );

		// WebXR
		document.body.appendChild( THREE.WEBVR.createButton( renderer, { referenceSpaceType: 'local' } ) );

		// controllers

		function onSelectStart() {
			moveForward = true;
		}

		function onSelectEnd() {
			moveForward = false;
		}

		controller1 = renderer.vr.getController( 0 );
		controller1.addEventListener( 'selectstart', onSelectStart );
		controller1.addEventListener( 'selectend', onSelectEnd );
		scene.add( controller1 );

		controller2 = renderer.vr.getController( 1 );
		controller2.addEventListener( 'selectstart', onSelectStart );
		controller2.addEventListener( 'selectend', onSelectEnd );
		scene.add( controller2 );

		// helpers

		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) );
		geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );

		var material = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );

		controller1.add( new THREE.Line( geometry, material ) );
		controller2.add( new THREE.Line( geometry, material ) );

		window.addEventListener( 'resize', onWindowResize, false );

	}

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}

	function animate() {
		renderer.setAnimationLoop( render );
	}

	function render() {

		// console.log(train.quaternion);
		var time = performance.now();
		var delta = ( time - prevTime ) / 1000;

		velocity.x -= velocity.x * 10.0 * delta;
		velocity.z -= velocity.z * 10.0 * delta;
		direction.z = Number( moveForward ) - Number( moveBackward );
		direction.x = Number( moveLeft ) - Number( moveRight );
		direction.normalize(); // this ensures consistent movements in all directions

		if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
		if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;
		
		var translation = new THREE.Vector3(velocity.x * delta, 1, velocity.z * delta);
		
		var directionVec = new THREE.Vector3(0,0,-1);
		directionVec.applyQuaternion(camera.quaternion);
		// var directionVec = new THREE.Vector3(0, 0, -1);
		// directionVec.applyEuler(camera.rotation, camera.rotation.order);

		console.log(directionVec);

		controls.getObject().translateX( translation.x * directionVec.x );
		controls.getObject().position.y = 10;
		controls.getObject().translateZ( translation.z * directionVec.z );
		// controls.getObject().translateX( velocity.x * delta );
		// controls.getObject().position.y = 10;
		// controls.getObject().translateZ( velocity.z * delta );

		prevTime = time;

		renderer.render( scene, camera );

	}
</script>
</body>
</html>