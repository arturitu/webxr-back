<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Go Back (And Do It Again)</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0;
			}
			canvas {
				display: block;
			}
		</style>
</head>
<body>
<script type="module">
    import * as THREE from "/three.module.js";
    var PointerLockControls = function ( camera, domElement ) {

        this.domElement = domElement || document.body;

        //
        // internals
        //

        var scope = this;

        var changeEvent = { type: 'change' };

        var euler = new THREE.Euler( 0, 0, 0, 'YXZ' );

        var PI_2 = Math.PI / 2;

        function onMouseMove( event ) {

			var c = document.getElementById("c")
            var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

            euler.setFromQuaternion( camera.quaternion );

            euler.y = (1 - normalize(event.x, c.width, 0)) * Math.PI*2 - Math.PI;
            euler.x = (1 - normalize(event.y, c.height, 0)) * Math.PI - PI_2;

            // euler.x = Math.max( - PI_2, Math.min( PI_2, euler.x ) );

            camera.quaternion.setFromEuler( euler );

            scope.dispatchEvent( changeEvent );

		}
		
		function normalize (val, max, min) { return (val - min) / (max - min) }

        this.connect = function () {

            document.addEventListener( 'mousemove', onMouseMove, false );

        };

        this.disconnect = function () {

            document.removeEventListener( 'mousemove', onMouseMove, false );

        };

        this.dispose = function () {

            this.disconnect();

        };

        this.getObject = function () { // retaining this method for backward compatibility

            return camera;

        };

        this.getDirection = function () {

            var direction = new THREE.Vector3( 0, 0, - 1 );

            return function ( v ) {

                return v.copy( direction ).applyQuaternion( camera.quaternion );

            };

        }();

        this.connect();

    };

    PointerLockControls.prototype = Object.create( THREE.EventDispatcher.prototype );
    PointerLockControls.prototype.constructor = PointerLockControls;

	var camera, scene, renderer, controls;
	var controller1, controller2;
	var train, world;

	var prevTime = performance.now();

	init();
	animate();

	function init() {

		scene = new THREE.Scene();
		scene.background = new THREE.Color( 0xdeb307 );
		scene.fog = new THREE.Fog( 0xdeb307, 0, 75 );

		world = new THREE.Object3D();
		world.position.y = -1.7;
		scene.add(world)

		train = new THREE.Object3D();
		scene.add( train );

		camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
		camera.layers.enable( 1 );
		scene.add( camera );

		var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
		light.position.set( 0.5, 1, 0.75 );
		scene.add( light );

		controls = new PointerLockControls( train );

		scene.add( controls.getObject() );

		// floor

		var floorGeometry = new THREE.PlaneBufferGeometry( 2000, 2000, 100, 100 );
		floorGeometry.rotateX( - Math.PI / 2 );

		var floorMaterial = new THREE.MeshBasicMaterial( { color: 0xf6d242 } );

		var floor = new THREE.Mesh( floorGeometry, floorMaterial );
		world.add( floor );

		// point lights
		var spheres = []
		var sphereGeometry = new THREE.SphereBufferGeometry(0.35,4,2)
		var sphereMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, emissive: 0xffffff } );
		for ( var i = 0; i < 50; i ++ ) {
			var sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
			sphere.position.x = Math.floor( Math.random() * 5 ) * 2 - 4;
			sphere.position.y = 1.5;
			sphere.position.z = -20 * Math.ceil( Math.random() * 50 );
			spheres.push(sphere)
			world.add( sphere );
		}

		var ways = [];
		var wayGeometry = new THREE.PlaneBufferGeometry( 1.9, 2000, 1, 1 );
		wayGeometry.rotateX( - Math.PI / 2 );
		// ways
		for ( var i = 0; i < 5; i ++ ) {
			var wayMaterial = new THREE.MeshBasicMaterial({ color: 0xeebf2d });
			var way = new THREE.Mesh( wayGeometry, wayMaterial );
			way.position.x = (i*2) - 4;
			way.position.y = 0.1;
			way.position.z = 0;
			ways.push(way)
			world.add( way );
			// TODO - tú no te mueves, se mueve todo lo demás
		}

		// objects

		var boxGeometry = new THREE.BoxBufferGeometry( 20, 20, 20 );
		// var boxMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, emissive: 0xffffff } );
		var boxMaterial = new THREE.MeshStandardMaterial( { color: 0xf6d242 } );
		for ( var i = 0; i < 500; i ++ ) {
			var box = new THREE.Mesh( boxGeometry, boxMaterial );
			box.position.x = Math.floor( Math.random() * 20 - 10 ) * 20;
			box.position.y = Math.floor( Math.random() * 5 ) * 20 + 20;
			box.position.z = -20 * Math.ceil( Math.random() * 50 );

			world.add( box );

		}

		//

		renderer = new THREE.WebGLRenderer( {antialias:true});
		renderer.domElement.id = "c";
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.vr.enabled = true;
		document.body.appendChild( renderer.domElement );

		// WebXR
		document.body.appendChild( THREE.WEBVR.createButton( renderer, { referenceSpaceType: 'local' } ) );

		// controllers

		function onSelectStart() {
			
		}

		function onSelectEnd() {
		}
		
		controller1 = renderer.vr.getController( 0 );
		controller1.addEventListener( 'selectstart', onSelectStart );
		controller1.addEventListener( 'selectend', onSelectEnd );
		scene.add( controller1 );

		controller2 = renderer.vr.getController( 1 );
		controller2.addEventListener( 'selectstart', onSelectStart );
		controller2.addEventListener( 'selectend', onSelectEnd );
		scene.add( controller2 );

		// helpers

		var geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );
		var material = new THREE.LineBasicMaterial( {color: 0x000000} );
		var line = new THREE.Line( geometry, material);
		line.name = 'line';
		line.scale.z = 5;

		controller1.add( line.clone() );
		controller2.add( line.clone() );

		window.addEventListener( 'resize', onWindowResize, false );

	}

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}

	function animate() {
		renderer.setAnimationLoop( render );
	}

	function render() {
		var time = performance.now();
		var delta = ( time - prevTime ) / 1000;

		world.position.z += 10 * delta;

		prevTime = time;

		renderer.render( scene, camera );

	}
</script>
</body>
</html>